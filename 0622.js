var name = [1, 2, 3];

/*--------------------------------------------------------------------------------------------------*/

// 오브젝트
var name2 = {
  name: "kim",
  age: "20",
};

console.log(name.age);

/*--------------------------------------------------------------------------------------------------*/

//forEach,  콜백 함수 필요
name.forEach(function (a) {
  console.log(a);
});

/*--------------------------------------------------------------------------------------------------*/

//   'this' keword
//   this의 뜻 : 1. window (전역에서 or 함수안에서)
//               2. undefined (strict mod 사용 시)
//               3. 오브젝트 내의 메소드 안의 'this'는 메소드가 동작하는 오브젝트를 뜻함.
//               4. 이벤트리스너 내에서 'this'는 이벤트가 동작하는 곳의 html 태그

/*--------------------------------------------------------------------------------------------------*/

var 오브젝트 = {
  data: "kim",
  함수: function () {
    console.log(this);
  },
}; /// 3. 케이스에 해당, 여기서의 'this'는 메소드(함수)를 포함하는 오브젝트를 가르킨다.
오브젝트.data.함수();

/*--------------------------------------------------------------------------------------------------*/
//constructor 생성자(오브젝트를 만드는 기계) 내에서 'this'는 새로 생성될 오브젝트('intance')를 뜻함.

function 기계() {
  this.이름 = "kim";
} //constructor

var 오브젝트1 = new 기계(); // 기계를 통한 새 오브젝트 생성, 이러면 오브젝트1의 '이름' 프로퍼티는 'kim'이 됨
console.log(오브젝트1.이름);

/*--------------------------------------------------------------------------------------------------*/

//이벤트리스너 내의 'this'는 e.curruntTaget과 같음, 이벤트가 동작하는 곳의 html 태그가 출력
document.getElementById("button").addEventListener("click", function () {
  console.log(this);
}); //이러면 위쪽 어딘가의 id가 button 코드 줄이 출력됨.

/*--------------------------------------------------------------------------------------------------*/

//함수안의 함수를 콜백함수라 한다.
var 어레이 = [1, 2, 3];
어레이.forEach(function (a) {
  console.log(a);
}); // 1,2,3이 출력될듯, 콜백함수 내의 'this'는 window를 출력함. 2번과 가깝다.

var 오브젝트3 = {
  이름들: ["kim", "choi", "park"],
  함수: function () {
    오브젝트3.이름들.forEach(function () {
      console.log(this); //여기서의 'this'는 window가 출력됨. 오브젝트 내의 함수 내의 함수라서..? BUT, 애로우펑션을 쓰면 상위 this를 그대로 물려받는다.
    });
  },
};

// Arrow funtion의 특징: 'this'값을 재설정하지 않는다. 즉, 상위 'this'를 물려받아 출력, ()=>{}, bind, call 함수가 필요없어짐
var 오브젝트4 = {
  이름들: ["kim", "choi", "park"],
  함수: function () {
    오브젝트4.이름들.forEach(() => {
      console.log(this); //여기서의 'this'는 오브젝트 바로 아래 'this'를 물려받아 오브젝트를 뜻하게 된다.
    });
  },
};

/*--------------------------------------------------------------------------------------------------*/

// 공부를 하는 중에 github의 public key에 대해 문제가 있어 push가 진행되지 않았다.
// public ssh key를 생성해야 다른 ip에서도 push가 가능하다고 한다.

// 키 생성 방법
// cmd에서
// ssh-keygen -t rsa -C 본인이메일
// 계속 엔터
// 하면 C:user/.ssh에 id_rsa.pub 파일이 생성되었을 것
// 메모장으로 열어 전체 복사 후 github setting 내의 ssh key를 설정해주면 끝!

/*--------------------------------------------------------------------------------------------------*/

//함수는 항상 목적에 맞게 1. 기능을 만들고 싶을떄, 2. 입출력 기계를 만들고 싶을떄

var 함수 = (a)=>a+10;
함수(5);


[1,2,3,4].forEach((a)=>{console.log(a)});

//이벤트 리스너 내에서 Arrow Function을 쓰면 안된다. 바깥의 'this'가 되어버림

var 오브젝트 = {
  함수:()=>{
    this              // 이 경우에는 오브젝트가 아니고 window가 나옴
  }
}    

/*------------------------------------예제--------------------------------------------------------------*/
//예제 1번

var 사람 ={
  name:손흥민,
  Sayhi: ()=>{
    console.log('안녕 나는'+this.name)
  }
}
사람.Sayhi();


//예제 2번
var 자료 ={
  data : [1,2,3,4,5],
}

자료.전부더하기() = function(){
  var b = 0;
  this.data.forEach((a)=>{
    b=b+a;
  });
  console.log(b);
}

전부더하기();

//예제 3번
'click', setTimeout((()=>{console.log(this.innerHTML)},1000)); //함수 내의 'this' 때문에 arrow function을 이용해야됨...  이벤트리스너내의 사용 HTML 태그 'this'를 물려받기 위해..
                                                               //function(){...} 로 함수를 만들면 'this'는 window가 나온다.